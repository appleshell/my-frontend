---
title: 排序算法
---

[算法图示](https://visualgo.net/zh/sorting)

## 如何分析一个排序算法

### 排序算法的执行效率

### 排序算法的内存消耗

### 排序算法的稳定性

## 冒泡排序

## 插入排序

将待排序的数列分为已排序和未排序两部分，即可认为是将未排序数组中的每一个值插入到已排序数组中的正确位置。

排序开始时，已排序数组就是第一个元素，未排序数组就是剩余的元素

每次排序，取出未排序数组的第一个元素，与已排序数组每个元素倒序遍历比较大小，如果未排序的元素小，则两者交换位置

交换位置的操作，将大的元素的下标后移一位，小元素需要存放在临时变量中，大元素移动完毕后，将小元素放到大元素原来的位置

```js
const arr = [6, 4, 23, 5, 7, 3, 4, 6, 8, 9];

function sort(arr) {
  const n = arr.length; // 元素个数

  for (let i = 1; i < n; i++) { // 外循环是遍历未排序的部分，从index = 1开始
    const value = arr[i] // 临时存放未排序的元素，防止交换位置时丢失
    for(let j = i - 1; j >= 0; j--) { // 内循环遍历的是已排序的部分，倒序遍历，依次与arr[i]比较
      if(arr[j] > value) { // 如果未排序的元素小，两者交换位置
        arr[j + 1] = a[j] // 大元素后移一位
        arr[j] = value // 小元素插入到到大元素原来位置，这一步可有可无有，插入的操作在遍历结束的时候执行一次也行
      } else {
        break
      }
    }
    // a[j + 1] = value // 插入数据的操作可以放在内循环遍历结束，循环中就只是比较大小和移动大元素。不过我自己认为这个对理解不太友好
  }
}
```

## 选择排序
